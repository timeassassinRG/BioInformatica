---
title: "Multi Layer Graph Analysis"
output: html_notebook
---

```{r}
library(ggplot2)
library(ggraph)
library(grid)
library(igraph)
library(muxViz)
library(RColorBrewer)
library(progress)
```

```{r}
rm(list = ls())
#Lettura del grafo completo
grafo <- read_graph("multilayer.graphml", format = "graphml")
```

```{r}
# Estrai i tipi di layer e i nomi dei nodi utilizzando l'ID del nodo, pulendo i dati in un unico passaggio
nodi_e_layer <- strsplit(V(grafo)$id, split = "', '", fixed = TRUE)
nomi_nodi <- unique(sapply(nodi_e_layer, function(x) gsub("[()']", "", x[1])))
tipi_layer <- unique(sapply(nodi_e_layer, function(x) gsub("[')]", "", x[2])))

# Stampa per verifica
print(head(nomi_nodi))
print(tipi_layer)
```
```{r}
# Aggiungi un attributo 'name' a ciascun nodo nel grafo originale contenente solo il nome del gene
V(grafo)$name <- sapply(V(grafo)$id, function(id) {
  # Estrai solo il nome del gene dall'ID del nodo
  nome_gene <- gsub("[()']", "", strsplit(id, ", ")[[1]][1])
  nome_gene
})

# Verifica che l'attributo 'name' sia stato aggiunto correttamente
head(V(grafo)$name)
```

```{r}
# Prepara un set completo di nodi per ogni tipo di layer
nodi_completi_per_layer <- expand.grid(nomi_nodi, tipi_layer)
colnames(nodi_completi_per_layer) <- c("nome", "layer")
```

```{r}
sottografi <- list()
for (layer in tipi_layer) {
  # Crea un sottografo vuoto
  sottografo <- make_empty_graph(n = length(nomi_nodi))
  # Assegna i nomi dei nodi
  V(sottografo)$name <- nomi_nodi
  # Salva il sottografo inizializzato
  sottografi[[layer]] <- sottografo
}
```

```{r}
# precalcolo degli indici
indice_nodi <- list()
for(layer in tipi_layer) {
  nomi_nodi_layer_specifici <- V(sottografi[[layer]])$name
  indice_nodi[[layer]] <- setNames(seq_along(nomi_nodi_layer_specifici), nomi_nodi_layer_specifici)
}
```

```{r}
# Operazione più onerosa in assoluto, quindi non eseguire, i grafi risultati da questa operazione sono salvati nella directory
for(e in E(grafo)) {
  if(e %% 100 == 0) {
    cat("arco: ", e, "/144431 \n")
  }
  nodi_ends <- ends(grafo, e)
  sorgente <- V(grafo)[nodi_ends[1]]$name
  destinazione <- V(grafo)[nodi_ends[2]]$name
  tipo_layer <- E(grafo)[e]$type
  if(tipo_layer != "interlayer") {
    indice_sorgente <- indice_nodi[[tipo_layer]][sorgente]
    indice_destinazione <- indice_nodi[[tipo_layer]][destinazione]
    sottografi[[tipo_layer]] <- add_edges(sottografi[[tipo_layer]], c(indice_sorgente, indice_destinazione))
  }
}
```


```{r}
# verifiche
# Stampa il numero di nodi e archi per ciascun sottografo
lapply(sottografi, function(g) {
  list(numero_nodi = gorder(g), numero_archi = gsize(g))
})

# Verifica la presenza di un nodo specifico in un sottografo
nome_nodo_specifico <- "('nome_gene', 'expression')"
layer = "expression" # Assicurati di sostituire 'nome_gene' con un nome di gene valido e 'expression' con il layer corretto
if(nome_nodo_specifico %in% V(sottografi[[layer]])$id) {
  print(paste("Il nodo", nome_nodo_specifico, "è presente nel sottografo", layer))
} else {
  print(paste("Il nodo", nome_nodo_specifico, "NON è presente nel sottografo", layer))
}

# Controlla alcuni archi per un sottografo specifico
head(E(sottografi[[layer]]))
```

```{r}
# Estrai l'elenco dei nomi dei nodi dal grafo completo, manipolando la stringa dell'ID
tutti_nodi <- sapply(V(grafo)$id, function(id) {
  parti <- strsplit(gsub("[()']", "", id), ", ")[[1]]
  nome_gene <- parti[1]
  return(nome_gene)
})

# Elimina eventuali duplicati, se presenti
tutti_nodi <- unique(tutti_nodi)
```

```{r}
aggiungi_nodi_mancanti <- function(sottografo, nodi_completi) {
  nodi_attuali <- V(sottografo)$name
  nodi_da_aggiungere <- setdiff(nodi_completi, nodi_attuali)
  
  for (nodo in nodi_da_aggiungere) {
    sottografo <- add_vertices(sottografo, 1, name = nodo)
  }
  
  return(sottografo)
}
```


```{r}
#Network setup
Layers <- 3
layerCouplingStrength <- 1
networkOfLayersType <- "categorical"
layer.colors <- brewer.pal(3, "Set2")
```

```{r}
nodeTensor <- list()
for(l in 1:Layers){
  nodeTensor[[l]] <- igraph::get.adjacency(g.list[[l]])
}
```

```{r}
#Define the network of layers
layerTensor <-
  BuildLayersTensor(
    Layers = Layers,
    OmegaParameter = layerCouplingStrength,
    MultisliceType = networkOfLayersType
  )
```

```{r}
# Aggiusta le dimensioni delle matrici di adiacenza per assicurare la coerenza
adjust_adjacency_matrix <- function(mat, total_nodes) {
  # Crea una matrice quadrata con dimensioni pari al numero totale di nodi
  # Inizializzata a 0 (nessuna connessione)
  adjusted_mat <- matrix(0, nrow = total_nodes, ncol = total_nodes)
  
  # Sostituisci la porzione corrispondente con la matrice di adiacenza originale
  dimnames(adjusted_mat) <- list(rownames(mat), colnames(mat))
  adjusted_mat[rownames(mat), colnames(mat)] <- mat
  
  return(adjusted_mat)
}

# Numero totale di nodi nel grafo
total_nodes <- gorder(grafo)

# Regola le dimensioni di ciascuna matrice di adiacenza in 'nodeTensor'
for(l in 1:Layers){
  nodeTensor[[l]] <- adjust_adjacency_matrix(nodeTensor[[l]], total_nodes)
}
```